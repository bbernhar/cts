{"version":3,"sources":["../../../../../src/webgpu/api/validation/copy_between_linear_data_and_texture/copyBetweenLinearDataAndTexture.ts"],"names":["poptions","assert","kTextureFormatInfo","ValidationTest","kAllTestMethods","CopyBetweenLinearDataAndTextureTest","bytesInACompleteRow","copyWidth","format","blockWidth","bytesPerBlock","requiredBytesInCopy","layout","copyExtent","rowsPerImage","blockHeight","height","width","depth","texelBlockRowsPerImage","bytesPerImage","bytesPerRow","bytesInLastSlice","testRun","textureCopyView","textureDataLayout","size","dataSize","method","success","submit","data","Uint8Array","expectValidationError","device","defaultQueue","writeTexture","buffer","createBuffer","usage","GPUBufferUsage","COPY_SRC","encoder","createCommandEncoder","copyBufferToTexture","cmd","finish","COPY_DST","copyTextureToBuffer","createAlignedTexture","copySize","origin","x","y","z","createTexture","Math","max","GPUTextureUsage","valuesToTestDivisibilityBy","number","values","i","push","texelBlockAlignmentTestExpanderForOffset","texelBlockAlignmentTestExpanderForRowsPerImage","texelBlockAlignmentTestExpanderForValueToCoordinate","coordinateToTest","formatCopyableWithMethod","copySrc","copyDst"],"mappings":"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","sourcesContent":["import { poptions } from '../../../../common/framework/params_builder.js';\nimport { assert } from '../../../../common/framework/util/util.js';\nimport { kTextureFormatInfo } from '../../../capability_info.js';\nimport { ValidationTest } from '../validation_test.js';\n\nexport const kAllTestMethods = [\n  'WriteTexture',\n  'CopyBufferToTexture',\n  'CopyTextureToBuffer',\n] as const;\n\nexport class CopyBetweenLinearDataAndTextureTest extends ValidationTest {\n  bytesInACompleteRow(copyWidth: number, format: GPUTextureFormat): number {\n    assert(copyWidth % kTextureFormatInfo[format].blockWidth! === 0);\n    return (\n      (kTextureFormatInfo[format].bytesPerBlock! * copyWidth) /\n      kTextureFormatInfo[format].blockWidth!\n    );\n  }\n\n  requiredBytesInCopy(\n    layout: GPUTextureDataLayout,\n    format: GPUTextureFormat,\n    copyExtent: GPUExtent3DDict\n  ): number {\n    assert(layout.rowsPerImage! % kTextureFormatInfo[format].blockHeight! === 0);\n    assert(copyExtent.height % kTextureFormatInfo[format].blockHeight! === 0);\n    assert(copyExtent.width % kTextureFormatInfo[format].blockWidth! === 0);\n    if (copyExtent.width === 0 || copyExtent.height === 0 || copyExtent.depth === 0) {\n      return 0;\n    } else {\n      const texelBlockRowsPerImage = layout.rowsPerImage! / kTextureFormatInfo[format].blockHeight!;\n      const bytesPerImage = layout.bytesPerRow * texelBlockRowsPerImage;\n      const bytesInLastSlice =\n        layout.bytesPerRow * (copyExtent.height / kTextureFormatInfo[format].blockHeight! - 1) +\n        (copyExtent.width / kTextureFormatInfo[format].blockWidth!) *\n          kTextureFormatInfo[format].bytesPerBlock!;\n      return bytesPerImage * (copyExtent.depth - 1) + bytesInLastSlice;\n    }\n  }\n\n  testRun(\n    textureCopyView: GPUTextureCopyView,\n    textureDataLayout: GPUTextureDataLayout,\n    size: GPUExtent3D,\n    {\n      dataSize,\n      method,\n      success,\n      submit = false, // If submit is true, the validaton error is expected to come from the submit and encoding should succeed.\n    }: { dataSize: number; method: string; success: boolean; submit?: boolean }\n  ): void {\n    switch (method) {\n      case 'WriteTexture': {\n        const data = new Uint8Array(dataSize);\n\n        this.expectValidationError(() => {\n          this.device.defaultQueue.writeTexture(textureCopyView, data, textureDataLayout, size);\n        }, !success);\n\n        break;\n      }\n      case 'CopyBufferToTexture': {\n        const buffer = this.device.createBuffer({\n          size: dataSize,\n          usage: GPUBufferUsage.COPY_SRC,\n        });\n\n        const encoder = this.device.createCommandEncoder();\n        encoder.copyBufferToTexture({ buffer, ...textureDataLayout }, textureCopyView, size);\n\n        if (submit) {\n          const cmd = encoder.finish();\n          this.expectValidationError(() => {\n            this.device.defaultQueue.submit([cmd]);\n          }, !success);\n        } else {\n          this.expectValidationError(() => {\n            encoder.finish();\n          }, !success);\n        }\n\n        break;\n      }\n      case 'CopyTextureToBuffer': {\n        const buffer = this.device.createBuffer({\n          size: dataSize,\n          usage: GPUBufferUsage.COPY_DST,\n        });\n\n        const encoder = this.device.createCommandEncoder();\n        encoder.copyTextureToBuffer(textureCopyView, { buffer, ...textureDataLayout }, size);\n\n        if (submit) {\n          const cmd = encoder.finish();\n          this.expectValidationError(() => {\n            this.device.defaultQueue.submit([cmd]);\n          }, !success);\n        } else {\n          this.expectValidationError(() => {\n            encoder.finish();\n          }, !success);\n        }\n\n        break;\n      }\n    }\n  }\n\n  // This is a helper function used for creating a texture when we don't have to be very\n  // precise about its size as long as it's big enough and properly aligned.\n  createAlignedTexture(\n    format: GPUTextureFormat,\n    copySize: GPUExtent3DDict = { width: 1, height: 1, depth: 1 },\n    origin: Required<GPUOrigin3DDict> = { x: 0, y: 0, z: 0 }\n  ): GPUTexture {\n    return this.device.createTexture({\n      size: {\n        width: Math.max(1, copySize.width + origin.x) * kTextureFormatInfo[format].blockWidth!,\n        height: Math.max(1, copySize.height + origin.y) * kTextureFormatInfo[format].blockHeight!,\n        depth: Math.max(1, copySize.depth + origin.z),\n      },\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n  }\n}\n\n// For testing divisibility by a number we test all the values returned by this function:\nfunction valuesToTestDivisibilityBy(number: number): Iterable<number> {\n  const values = [];\n  for (let i = 0; i <= 2 * number; ++i) {\n    values.push(i);\n  }\n  values.push(3 * number);\n  return values;\n}\n\ninterface WithFormat {\n  format: GPUTextureFormat;\n}\n\ninterface WithFormatAndCoordinate extends WithFormat {\n  coordinateToTest: keyof GPUOrigin3DDict | keyof GPUExtent3DDict;\n}\n\ninterface WithFormatAndMethod extends WithFormat {\n  method: string;\n}\n\n// This is a helper function used for expanding test parameters for texel block alignment tests on offset\nexport function texelBlockAlignmentTestExpanderForOffset({ format }: WithFormat) {\n  return poptions('offset', valuesToTestDivisibilityBy(kTextureFormatInfo[format].bytesPerBlock!));\n}\n\n// This is a helper function used for expanding test parameters for texel block alignment tests on rowsPerImage\nexport function texelBlockAlignmentTestExpanderForRowsPerImage({ format }: WithFormat) {\n  return poptions(\n    'rowsPerImage',\n    valuesToTestDivisibilityBy(kTextureFormatInfo[format].blockHeight!)\n  );\n}\n\n// This is a helper function used for expanding test parameters for texel block alignment tests on origin and size\nexport function texelBlockAlignmentTestExpanderForValueToCoordinate({\n  format,\n  coordinateToTest,\n}: WithFormatAndCoordinate) {\n  switch (coordinateToTest) {\n    case 'x':\n    case 'width':\n      return poptions(\n        'valueToCoordinate',\n        valuesToTestDivisibilityBy(kTextureFormatInfo[format].blockWidth!)\n      );\n\n    case 'y':\n    case 'height':\n      return poptions(\n        'valueToCoordinate',\n        valuesToTestDivisibilityBy(kTextureFormatInfo[format].blockHeight!)\n      );\n\n    case 'z':\n    case 'depth':\n      return poptions('valueToCoordinate', valuesToTestDivisibilityBy(1));\n  }\n}\n\n// This is a helper function used for filtering test parameters\nexport function formatCopyableWithMethod({ format, method }: WithFormatAndMethod): boolean {\n  if (method === 'CopyTextureToBuffer') {\n    return kTextureFormatInfo[format].copySrc;\n  } else {\n    return kTextureFormatInfo[format].copyDst;\n  }\n}\n"],"file":"copyBetweenLinearDataAndTexture.js"}